<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>jasmine-kissy</title>
    <link rel="stylesheet" href="http://cdn.staticfile.org/twitter-bootstrap/3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="http://docs.kissyui.com/1.4/source/guideline/templates/assets/com-prettify.css">
    <link rel="stylesheet" href="http://docs.kissyui.com/1.4/source/guideline/templates/assets/com.css">
    <script src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script>
    <script src="http://cdn.staticfile.org/twitter-bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script src="http://cdn.staticfile.org/prettify/r298/prettify.min.js"></script>
    <script src="http://g.tbcdn.cn/kissy/k/1.4.8/seed-min.js" data-config="{combine:true}"></script>
  </head>
  <body data-spy="scroll" data-target=".bs-docs-sidebar">
    <div id="header"><a href="http://docs.kissyui.com/" class="logo">kissy</a>
      <nav><a href="http://docs.kissyui.com/1.4/docs/html/coms.html">优秀组件推荐</a></nav>
    </div>
    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span3 bs-docs-sidebar">
          <ul data-spy="affix" data-offset-top="0" class="nav nav-list bs-docs-sidenav"></ul>
        </div>
        <div class="span9 bs-docs-content">
          <h1 data-id="undefined" class="title">jasmine-kissy</h1>
          <p class="author-wrapper"><span>组件有问题？旺旺联系作者：</span><a href="https://github.com/minghe" target="_blank" data-name="剑平" class="author"><img src="https://avatars.githubusercontent.com/u/724588?v=3&amp;s=60" alt="剑平"></a><span class="author-name">剑平</span>
          </p>
          <div class="common-link"><a href="../demo/index.html" target="_blank" class="demo">示例</a><a href="https://github.com/kissygalleryteam/jasmine-kissy" target="_blank" class="source">源码</a></div>
          <p class="com-info"><span class="info-label">View</span><span data-com="jasmine-kissy" class="J_View">316</span></p>
          <p class="com-info"><span class="info-label">所属分类</span><a href="http://kpm.taobao.net/list/框架&amp;工具">框架&amp;工具</a><span class="info-label tag-label">组件标签</span><a href="http://kpm.taobao.net/list/tag?tag=单元测试">单元测试</a>
          </p>
          <p class="com-info"><span class="info-label">kissy版本</span><span>1.4.X</span>
          </p><h2 id="-">综述</h2>
<p>jasmine-kissy是为了方便基于kissy的代码进行单元测试，而向<a href="http://pivotal.github.com/jasmine/">Jasmine</a>添加的扩展。</p>
<ul>
<li>版本：2.0.0</li>
<li>作者：明河</li>
<li>demo：<a href="http://kg.kissyui.com/jasmine-kissy/2.0.0/demo/index.html">http://kg.kissyui.com/jasmine-kissy/2.0.0/demo/index.html</a></li>
</ul>
<p>jasmine-kissy主要扩展了如下四个功能</p>
<ul>
<li>1.增加kissy的ajax mock功能（伪造ajax的假数据方便进行ajax测试）</li>
<li>2.增加velocity mock功能，直接读取vm模版，使用伪数据mock出测试所依赖的html片段（dom）</li>
<li>3.增加html mock功能，同步加载html片段并插入到测试运行页中</li>
<li>4.增加用于KISSY的machers，只作用于KISSY的Node模块</li>
</ul>
<h2 id="-">测试代码的组织</h2>
<h4 id="-">动态源码模块的加载处理</h4>
<p>有2种方法：</p>
<ul>
<li>干掉异步加载过程，静态引用模块文件</li>
<li>异步加载完模块文件后，再执行jasmine运行测试用例</li>
</ul>
<p>这里明河推荐使用第二种方法，虽然会麻烦些。</p>
<p>所有的测试代码都放在test目录下。</p>
<p><img src="http://www.36ria.com/wp-content/uploads/2013/11/test.png" alt="test"></p>
<h4 id="-runner-html">测试入口文件runner.html</h4>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;
        &lt;title&gt;Runner&lt;/title&gt;
        &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; charset=&quot;utf-8&quot; href=&quot;http://assets.spmjs.org/totoro/jasmine/1.3.1/jasmine.css&quot; /&gt;
        &lt;script src=&quot;http://assets.spmjs.org/totoro/jasmine/1.3.1/jasmine.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;http://assets.spmjs.org/totoro/jasmine/1.3.1/jasmine-html.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;//g.tbcdn.cn/kissy/k/1.3.1/seed.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;http://a.tbcdn.cn/s/kissy/kg/??velocity/1.1/index-min.js,jasmine-kissy/2.0.0/ajax-base-min.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            (function() {
                var S = KISSY;
                S.config({
                    packages:[
                        {
                            name:&quot;test&quot;,
                            path:&#39;./&#39;,
                            ignorePackageNameInUri:true
                        }
                    ]
                });
                var jasmineEnv = jasmine.getEnv();
                jasmineEnv.updateInterval = 1000;
                var htmlReporter = new jasmine.HtmlReporter();
                jasmineEnv.addReporter(htmlReporter);

                S.use(&#39;kg/jasmine-kissy/2.0.0/&#39;,function(S,HtmlMock){
                    S.htmlMock = new HtmlMock();
                    S.use(&#39;test/runner&#39;,function(){
                        jasmineEnv.execute();
                    })
                })
            })()
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>核心代码如下：</p>
<pre><code>S.use(&#39;kg/jasmine-kissy/2.0.0/&#39;,function(S,HtmlMock){
    S.htmlMock = new HtmlMock();
    S.use(&#39;test/runner&#39;,function(){
        jasmineEnv.execute();
    })
})
</code></pre><h4 id="-runner-js">加载指定测试模块文件runner.js</h4>
<pre><code>KISSY.add(function(){

},{requires:[&#39;test/spec/html-mock-spec&#39;,&#39;test/spec/ajax-mock-spec&#39;,&#39;test/spec/velocity-mock-spec&#39;,&#39;test/spec/matchers-spec&#39;]})
</code></pre><p>requires指定测试用例文件。</p>
<h4 id="-">测试模块如何写？</h4>
<p>以test/spec/html-mock-spec.js为例</p>
<pre><code>KISSY.add(function (S, Node) {
    var $ = Node.all;
    var htmlMock = S.htmlMock;
    describe(&#39;test fixture&#39;, function () {
        var url1 = &#39;./fixture/jasmine-kissy_fixture.html&#39;;
        it(&#39;成功读取html片段文件&#39;, function () {
            htmlMock.load(url1);
            expect($(&#39;#test&#39;)).toExist();
            expect(htmlMock.cache[url1]).not.toBeUndefined();
        });
        it(&#39;清理缓存和html片段&#39;, function () {
            htmlMock.clean();
            htmlMock.cleanCache();
            expect($(&#39;#test&#39;)).not.toExist();
            expect(htmlMock.cache[url1]).toBeUndefined();
        });
    });

},{requires:[&#39;node&#39;]});
</code></pre><p>describe包裹在add()内，然后requires源码模块js。</p>
<h2 id="ajax-mock">ajax mock</h2>
<p>jasmine-kissy中的ajax mock远比<a href="https://github.com/pivotal/jasmine-ajax">jasmine ajax</a>来的强大。</p>
<ul>
<li>你无需修改任何源码js</li>
<li>能够直接截获接口，当脚本向接口发送请求时，直接劫持到伪结果集</li>
<li>简单，根据status自动返回对应的结果集，你只需要书写一份伪数据</li>
<li>完美支持jsonp，无需任何标识</li>
<li>支持kissy的所有io方法，比如get()、post()、jsonp等</li>
</ul>
<p>目前不支持mock io.upload()。</p>
<h4 id="-">引入依赖文件</h4>
<p>想要mock kissy的ajax，需要覆盖&quot;ajax/base&quot;模块，所以不能引入kissy.js文件，只能引用seed-min.js，然后引入ajax-base-min.js文件，比如下面的代码：</p>
<pre><code>&lt;script src=&quot;http://a.tbcdn.cn/s/kissy/kg/??velocity/1.1/index-min.js,jasmine-kissy/2.0.0/ajax-base-min.js&quot;&gt;&lt;/script&gt;
</code></pre><h4 id="ajax-">ajax的伪数据</h4>
<pre><code>KISSY.add(function (S) {
    return [
        {
            status:2.0.0,
            responseText: &#39;{&quot;status&quot;:1,&quot;name&quot;:&quot;minghe&quot;}&#39;
        },
        {
            status:500,
            responseText:&#39;&#39;
        },
        {
            status:2.0.0,
            data:{site:&#39;36ria&#39;},
            responseText: &#39;{&quot;status&quot;:2,&quot;site&quot;:&quot;36ria&quot;}&#39;
        },
        {
            status:2.0.0,
            responseText: &#39;jsonp1234({&quot;status&quot;:1,&quot;name&quot;:&quot;minghe&quot;})&#39;
        },
        {
            status:2.0.0,
            data:{site:&#39;36ria&#39;},
            responseText: &#39;jsonp5454({&quot;status&quot;:2,&quot;site&quot;:&quot;36ria&quot;})&#39;
        }
    ]
});
</code></pre><p>一份伪数据为一个数组，包含各种状态下的结果集，比如成功，失败，传入不同参数时。</p>
<ul>
<li>status：值为2.0.0时，为成功状态，会触发io的<strong>sucess</strong>事件</li>
<li>data：为前端传递给服务器端的参数，对应io的<strong>data</strong>参数，当不存在匹配时，mock类会返回不带参数的结果集</li>
<li>responseText：文本结果集，留意jsonp时的文本，mock类会自动判断jsonp</li>
</ul>
<h4 id="mock-">mock 的使用</h4>
<pre><code>    var api = &quot;http://service.taobao.com/support/minerva/ajax/refundPlugAjax.htm&quot;;
    //使用mock
    io.useMock = true;
    //装入伪数据
    io.install(api, simpleData);
    //使用成功状态的假数据
    io.use(api, 2.0.0);
</code></pre><p><strong>io.useMock=true</strong> 开启ajax mock</p>
<p><strong>io.install(api, simpleData)</strong> 装入伪数据，simpleData即上面的demo数据</p>
<p><strong>io.use(api, 2.0.0)</strong> 使用成功状态的伪数据</p>
<p> 接下来可以使用io方法试试</p>
<pre><code>        // 用于ajax的回调测试
        onSuccess = jasmine.createSpy(&#39;onSuccess&#39;);
        //触发异步请求
        S.io({
            url:api,
            type:&quot;GET&quot;,
            success:function (data, status) {
                onSuccess(data);
            }
        });

        var successResult = onSuccess.mostRecentCall.args[0];
        expect(onSuccess).toHaveBeenCalledWith(jasmine.any(Object));
        expect(successResult.status).toEqual(1);
        expect(successResult.name).toEqual(&#39;minghe&#39;);
</code></pre><p>onSuccess方法将会被执行一次，并且它的第一个参数的值为：</p>
<pre><code>{&quot;status&quot;:1,&quot;name&quot;:&quot;minghe&quot;}
</code></pre><p>如果你想要mock 接口失败时的情况</p>
<pre><code>    it(&#39;use error data mock&#39;,function(){
        //使用失败状态的假数据
        io.use(api,500);

        onError = jasmine.createSpy(&#39;onError&#39;);

        //触发异步请求
        S.io({
            url:api,
            type:&quot;GET&quot;,
            error:function(data){
                onError(data);
            }
        });

        expect(onError).toHaveBeenCalled();
    });
</code></pre><p>mock jsonp的接口情况也是如此</p>
<pre><code>        io.use(api,2.0.0);

        onSuccess = jasmine.createSpy(&#39;onSuccess&#39;);
        //异步请求带上不存在的参数
        S.io.jsonp(api,function(data){
            onSuccess(data);
        });
        var successResult = onSuccess.mostRecentCall.args[0];
        expect(onSuccess).toHaveBeenCalledWith(jasmine.any(Object));
        expect(successResult.status).toEqual(1);
        expect(successResult.name).toEqual(&#39;minghe&#39;);
</code></pre><p>如果你想要mock，不同传参下的接口</p>
<pre><code>        io.use(api,2.0.0);

        onSuccess = jasmine.createSpy(&#39;onSuccess&#39;);
        //异步请求带上指定参数
        S.io({
            url:api,
            type:&quot;GET&quot;,
            data:{site:&#39;36ria&#39;},
            success:function (data, status) {
                onSuccess(data);
            }
        });
        var successResult = onSuccess.mostRecentCall.args[0];
        expect(onSuccess).toHaveBeenCalledWith(jasmine.any(Object));
        expect(successResult.status).toEqual(2);
        expect(successResult.site).toEqual(&#39;36ria&#39;);
</code></pre><p> 所有的mock都非常简单，你无需修改源码js，mock类会自动处理，你唯一要做的就是install伪数据，然后use你想要的结果集</p>
<h2 id="velocity-mock-">velocity mock的使用</h2>
<p>大多数业务逻辑的js测试都依赖于dom结构（采用mvc框架会好很多），velocity mock的功能是直接拉取工程中的vm文件，然后渲染出html片段，插入到body中。</p>
<h4 id="-vm-">我们准备一个vm模版</h4>
<p>list.vm内容如下:</p>
<pre><code>&lt;div class=&quot;scroller&quot;&gt;
    &lt;div class=&quot;ks-switchable-content&quot;&gt;
        #foreach($msg in $!currentProofMsg)
        &lt;div class=&quot;list-item J_ListItem&quot;&gt;
            #if($!msg.attachment)
            #set($newUrl =&quot;$!msg.attachment&quot;+&quot;_120x120.jpg&quot;)
            #set($originalUrl=&quot;$!msg.attachment&quot;+&quot;.jpg&quot;)
            &lt;img class=&quot;J_ImgDD&quot; data-original-url=&quot;$refundImageServer.getURI(&quot;refund/$originalUrl&quot;)&quot; src=&quot;$refundImageServer.getURI(&quot;refund/$newUrl&quot;)&quot;/&gt;
            #end
            &lt;div class=&quot;image-comment&quot;&gt;
                &lt;img class=&quot;comment-icon&quot; src=&quot;http://img02.taobaocdn.com/tps/i2/T1yhMcXbBdXXb38KzX-15-13.png&quot;/&gt;
                &lt;div class=&quot; J_ImageCommentContent&quot;&gt;
                    &lt;p class=&quot;comment-author&quot;&gt;$!roleName的留言：&lt;/p&gt;
                    &lt;p&gt;$!msg.content&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        #end
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>伪数据list.json内容如下：</p>
<pre><code>{
    &quot;MAP&quot;:{
        &quot;control&quot;:&quot;./vm&quot;
    },
    &quot;type&quot;:1,
    &quot;currentProofMsg&quot;:[
        {&quot;attachment&quot;:&quot;http://img01.taobaocdn.com/imgextra/i1/10361016579368429/T1zbCTXfdmXXXXXXXX_!!413810361-0-tstar&quot;,&quot;roleName&quot;:&quot;您&quot;,&quot;content&quot;:&quot;这是一条留言&quot;},
        {&quot;attachment&quot;:&quot;http://img01.taobaocdn.com/imgextra/i1/10361016579368429/T1zbCTXfdmXXXXXXXX_!!413810361-0-tstar&quot;,&quot;roleName&quot;:&quot;您&quot;,&quot;content&quot;:&quot;这是一条留言&quot;}
    ]
}
</code></pre><p>MAP是特殊关键字，后面明河会解释。</p>
<h4 id="-spec-htmlmock">在spec文件中引入HtmlMock</h4>
<pre><code>KISSY.add(function (S, Node) {
    var $ = Node.all;
    var htmlMock = S.htmlMock;
    describe(&#39;velocity mock test&#39;, function () {
        it(&#39;正确读取并解析vm模版&#39;,function(){
            htmlMock.load(&#39;./vm/list.vm&#39;,&#39;./vm/list.json&#39;);
            expect($(&#39;.scroller&#39;)).toExist();
            expect($(&#39;.J_ListItem&#39;).length).toBe(2);
            expect($(&#39;.J_ImgDD&#39;).length).toBe(2);
        })
        it(&#39;清理掉伪的html片段&#39;,function(){
            htmlMock.clean();
            expect($(&#39;.scroller&#39;)).not.toExist();
        })
    });

},{requires:[&#39;node&#39;]});
</code></pre><p><code>load()</code>方法有二个参数：</p>
<ul>
<li>vm模版路径，必填</li>
<li>伪数据路径，可以直接传入json数据，比如下面的代码</li>
</ul>
<pre><code>htmlMock.load(&#39;./vm/list.vm&#39;,{
    &quot;MAP&quot;:{
            &quot;control&quot;:&quot;./vm&quot;
        },
        &quot;type&quot;:1,
        &quot;currentProofMsg&quot;:[
            {&quot;attachment&quot;:&quot;http://img01.taobaocdn.com/imgextra/i1/10361016579368429/T1zbCTXfdmXXXXXXXX_!!413810361-0-tstar&quot;,&quot;roleName&quot;:&quot;您&quot;,&quot;content&quot;:&quot;这是一条留言&quot;},
            {&quot;attachment&quot;:&quot;http://img01.taobaocdn.com/imgextra/i1/10361016579368429/T1zbCTXfdmXXXXXXXX_!!413810361-0-tstar&quot;,&quot;roleName&quot;:&quot;您&quot;,&quot;content&quot;:&quot;这是一条留言&quot;}
        ]
});
</code></pre><h4 id="map-">MAP的用途</h4>
<p>MAP用于指定vm模版中依赖模版的路径，比如你的vm可能会出现<code>#parse(&quot;control/listImageComment.vm&quot;)</code>这样的引用，这时候就需要指定下<code>control</code>的路径映射。</p>
<h4 id="clean-">clean:清理模版</h4>
<p>测试运行结束后建议clean下模版，避免影响其他测试的准确度。</p>
<p><code>htmlMock.clean(&#39;./vm/list.vm&#39;)</code> ，不填入第一个参数时，会清理所有的html片段，不推荐！！！</p>
<p>加载的html片段会放在页面的测试容器内，容器id为<code>#J_JF</code>。</p>
<p>加载的片段会放入缓存，避免重复加载。</p>
<h2 id="html-mock-">html mock的使用</h2>
<p>html mock与velocity mock基本一样，更为简单，不需要第二个伪数据参数。</p>
<p>假设在你的<code>test/fixture</code>目录有个html片段文件<code>jasmine-kissy_fixture.html</code>。</p>
<p>文件的内容如下：</p>
<pre><code>&lt;div id=&quot;test&quot; class=&quot;test-wrapper&quot;&gt;
    my name is minghe.
&lt;/div&gt;
</code></pre><p>使用如下语法加载这个文件：</p>
<pre><code>htmlMock.load(&#39;./specs/jasmine-kissy_fixture.html&#39;);
</code></pre><p>你可以测试下#test这个div是否存在：</p>
<pre><code>expect(&#39;#test&#39;).toExist();
</code></pre><p>(ps:toExist()是jasmine-kissy新增的macher，用于测试节点是否存在)</p>
<h2 id="kissy-matchers">KISSY matchers</h2>
<ul>
<li><code>toExist()</code> 测试节点的存在性</li>
<li><code>toHasClass()</code> 测试节点是否拥有指定的class名</li>
<li><code>toHasAttr()</code> 测试节点是否拥有指定的属性值</li>
<li><code>toHasProp()</code> 测试节点是否拥有指定的property值</li>
<li><code>toHasData()</code> 测试节点是否拥有指定扩展属性值</li>
<li><code>toContain()</code> 测试节点是否有子节点</li>
<li><code>toEqualValue()</code> 测试节点的的value值</li>
<li><code>toEqualText()</code> 测试节点的text</li>
</ul>
<p>示例代码：</p>
<p>  expect($(&#39;#test&#39;)).toHasClass(&#39;test-wrapper&#39;);</p>
<p>  expect($(&#39;#test&#39;)).toEqualText(&#39;my name is minghe.&#39;);</p>

          <div style="display:none;"><script type="text/javascript" src="http://tajs.qq.com/stats?sId=36378479" charset="UTF-8"></script></div>
          <script src="http://docs.kissyui.com/1.4/source/guideline/templates/assets/com.js"></script>
        </div>
      </div>
    </div>
  </body>
</html>